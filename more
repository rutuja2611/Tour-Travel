# app = Flask(__name__)
# app.secret_key = 'your_secret_key'  # Change this to a secure secret key

# # Load user data from Excel sheet
# user_df = pd.DataFrame(columns=['username', 'email', 'country', 'city', 'area_code', 'password'])

# # Register page
# @app.route('/register', methods=['GET', 'POST'])
# def register():
#     global user_df  # Declare user_df as a global variable

#     if request.method == 'POST':
#         username = request.form['username']
#         email = request.form['email']
#         country = request.form['country']
#         city = request.form['city']
#         area_code = request.form['area_code']
#         password = request.form['password']
#         confirm_password = request.form['confirm_password']

#         # Check if passwords match
#         if password != confirm_password:
#             return render_template('register.html', error='Passwords do not match')

#         # Check if username is unique
#         if not user_df.empty and username in user_df['username'].values:
#             return render_template('register.html', error='Username already exists')

#         # Hash the password before storing
#         hashed_password = generate_password_hash(password, method='pbkdf2:sha256')

#         # Add user to DataFrame
#         new_user = {'username': username, 'email': email, 'country': country, 'city': city, 'area_code': area_code, 'password': hashed_password}
#         user_df = user_df.append(new_user, ignore_index=True)
#         user_df.to_excel('users.csv', index=False)

#         return redirect(url_for('login'))

#     return render_template('register.html')

# # Login page
# @app.route('/login', methods=['GET', 'POST'])
# def login():
#     if request.method == 'POST':
#         username = request.form['username']
#         password = request.form['password']

#         # Check if username exists
#         if username not in user_df['username'].values:
#             return render_template('login.html', error='Invalid username or password')

#         # Retrieve hashed password from DataFrame
#         stored_password = user_df.loc[user_df['username'] == username, 'password'].iloc[0]

#         # Check if the password is correct
#         if not check_password_hash(stored_password, password):
#             return render_template('login.html', error='Invalid username or password')

#         # Set the user session and redirect to home page
#         session['username'] = username
#         return redirect(url_for('home'))

#     return render_template('login.html')

# # Home page
# @app.route('/home')
# def home():
#     if 'username' in session:
#         return render_template('home.html')
#     else:
#         return redirect(url_for('login'))

# # Index page
# # @app.route('/')
# # def index():
# #     return render_template('index.html')

# # Recommendation page
# @app.route('/recommend')
# def recommend():
#     return render_template('recommend.html')

# # Logout
# @app.route('/logout')
# def logout():
    # session.pop('username', None)
    # return redirect(url_for('login'))


























# code using data.csv in app.py
# ****************************************

# # Load the dataset
# df = pd.read_csv("data.csv")

# @app.route("/index", methods=["GET", "POST"])
# def index():
#     if request.method == "POST":
#         city = request.form.get("city")
#         cuisines = request.form.get("cuisines")
        
#         # Retrieve min_rating and handle the case when it's not provided
#         try:
#             min_rating = float(request.form.get("min_rating"))
#         except (ValueError, TypeError):
#             # Set a default value if min_rating is not provided or invalid
#             min_rating = 1.0

#         # Filter the dataset based on user input
#         filtered_df = filter_data(city, cuisines, min_rating)

#         # Pass the filtered data to the result page
#         return render_template("result.html", data=filtered_df.to_dict(orient="records"))

#     return render_template("index.html")


# def filter_data(city, cuisines, min_rating):
#     # Remove rows with any empty values
#     df_cleaned = df.dropna(subset=['name', 'address', 'Phone', 'cuisines', 'rating'])

#     # Filter by city in the address
#     filtered_df = df_cleaned[df_cleaned['address'].str.contains(city, case=False)]

#     # Filter by cuisines
#     if cuisines:
#         filtered_df = filtered_df[filtered_df['cuisines'].str.contains(cuisines, case=False)]

#     # Filter by minimum rating
#     filtered_df = filtered_df[filtered_df['rating'] >= min_rating]    

#     # Sort by rating in descending order
#     filtered_df = filtered_df.sort_values(by='rating', ascending=False)

#     return filtered_df